# 任务二：JavaScript性能优化

#### 1.JavaScript中的垃圾

- 对象不再被引用时是垃圾
- 对象不能从根上访问到时是垃圾

#### 2.GC定义与作用

- 定义：GC是垃圾回收机制的简写
- 作用：可以找到内存中的垃圾、并释放和回收空间

#### 3.GC中的垃圾是什么

- 程序中不再需要使用到的对象
- 程序中不能再访问到的对象

#### 4.常见GC算法

- 引用计数

  ***核心思想***：设置引用数，判断当前引用数是否为0

  ```js
  const user1 = {age: 11}
  const user2 = {age: 22}
  const user3 = {age: 33}
  /*
  user1,user2,user3被nameList所引用着，所以其不算垃圾
  */
  const nameList = {user1.age,user2.age,user3.age}
  functon fn(){
      //此时num1,num2属性未设置const/let，因此num1，num2是挂载在window上
      //num1,num2是垃圾
      num1 = 1; 
      num2 = 2;
  }
  fn();
  ```

  ***优点***：

  - 发现垃圾时立即回收
  - 最大限度减少程序卡顿

  ***缺点***：

  - 无法回收循环引用的对象
  - 时间开销大

  ```js
  //代码演示
  function fn(){
      const obj1 = {}
      const obj2 = {}
      
      /*
      obj1.name指向obj2,obj2.name指向obj1,所以obj1,obj2不能被当作垃圾清除，这就是对象之间的循环引用，这样就造成了内存浪费
      */
      obj1.name = obj2;
      obj2.name = obj1;
      
      return 'lg is a coder';
  }
  fn() //无输出
  ```

- 标记清除

  ***核心思想***：分标记和清除两个阶段完成，第一阶段为先遍历所有对象找标记活动对象， 第二阶段遍历所有对象清除没有标记对象（同时将第一阶段设置的标记清除，便于下一次GC进行标记），回收相应空间

  ***优点***：相对于引用计数来说，可以解决循环引用不能回收的问题

  ***缺点***：***空间碎片化***（由于当前回收的垃圾对象在地址上的位置是不连续的，即他们的位置分散在内存中的各个角落，后续使用时，如果需要的新的空间大于或小于现有空间，则不适合使用）

- 标记整理

  标记整理可以看作标记清除的增强，因为它在标记阶段的操作和标记清除一致，不过它在整理阶段会先执行整理，移动对象的位置，让他们在地址上实现连续

  ***优点***：减少碎片化空间

  ***缺点***：不会立即回收垃圾对象

- 分代回收 

#### 5.认识V8

是什么：V8是一款主流的JavaScript执行引擎；

采用即时编译；

设有内存限制（64位操作系统不超过1.5G，32为操作系统不超过800M,）；

采用基于分代回收思想实现垃圾回收

#### 6.V8垃圾回收策略

(1)采用分代回收的思想（内存分为新生代、老生代）

- ​	新生代对象：存活时间较短的对象；

  ​	新生空间会等分为两份，将其命名为From空间，To空间。

- ​	老生代对象：存活时间较长的对象（例如：全局对象下存放的变量，闭包中放置的变量数据）。

  ​	主要采用标记清除、标记整理、增量标记算法

(2)针对不同对象采用不同算法

(3)新生代回收细节说明

​	拷贝过程中可能出现晋升。

​	晋升：将新生代对象移动至老生代；

​	晋升的条件：一轮GC还存活的新生代需要晋升；To空间的使用率超过25%

(4)新生代、老生代细节对比

​	新生代区域垃圾回收使用空间换时间

​	老生代区域垃圾回收不适合复制算法

#### 7.V8中常见GC算法

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

#### 8.为什么要使用Performance

通过Performance时刻监控内存

#### 9.Performance使用步骤

- 在浏览器中输入目标网址（只是输入，不访问）
- 进入开发人员工具面板，选择性能选项
- 开启录制功能，访问具体界面
- 执行用户行为，一段时间后停止录制
- 得到报告，分析界面中记录的内存信息

#### 10.内存问题的外在表现

- 页面出现延迟加载或经常性暂停
- 页面持续性出现糟糕的性能
- 页面的性能随时间延长越来越差

#### 11.界定内存问题的标准

- 内存泄漏：内存使用持续升高
- 内存膨胀：在多数设备上都存在性能问题
- 频繁垃圾回收：通过内存变化图进行分析

#### 12.监控内存的几种方式

- 浏览器任务管理器（快捷键：shift + esc）
- Timeline时序图记录
- 堆快照查找分离DOM
- 判断是否存在频繁的垃圾回收

#### 13.为什么确定频繁垃圾回收（GC）

- GC工作时应用程序是停止的
- 频繁且过长的GC会导致应用假死
- 用户使用中感知应用卡顿

#### 14.如何确定是否为频繁的垃圾回收

- TImeline中频繁的上升下降
- 任务管理器中数据频繁的增加减小

#### 15.为什么要慎用全局变量

- 全局变量定义在全局执行上下文，是所有作用域链的顶端
- 全局执行上下文一直存活于上下文执行栈，直到程序退出
- 如果某个局部作用域出现了同名变量则会遮蔽或污染全局

#### 16.闭包特点

- 外部具有指向内部的引用
- 在外部作用域访问内部作用域的数据

```js
//示例
function foo(){
    var name = 'lg';
    function fn(){
        console.log(name);
    }
    return fn();
}
var a = foo();
a()

//示例二
function fn(){
    var btn = document.getElementById('btn');
    btn.onclick = function(){
        console.log(btn,id);
    }
}
fn()
```

#### 17.如何解决闭包导致的内存泄露（避开闭包陷阱）

```js
function fn(){
    var btn = document.getElementById('btn');
    
    //由于变量btn在单击事件中有引用，所以变量btn无法回收，这边导致内存泄漏
    btn.onclick = function(){
        console.log(btn,id);
    }
    
    //划重点：执行完毕后将变量btn赋为null可解决
    btn = null; 
}
fn()
```

#### 18.for循环优化

```js
//在body中有10个p标签
//使用for循环遍历输出p标签
let PEle = document.getElementsByClassName
//方法一：
for(let i = 0; i < pEle.length; i++){
    console.log(i);
}

//方法二：将pEle的长度存储起来，不用每遍历一次都获取一遍,效率更高
for(let i = 0, len = pEle.length; i < len; i++){
    console.log(i);
}
```

#### 19.采用最优循环方式

按照最优排序为：***foreach()最优，for()第二，for...in第三***

```js
let arr = [1,2,3,4,5];
//foreach
arr.forEach(function(item){
    console.log(item);
});

//for
for(let i = arr.length; i; i--){
    console.log(arr[i]);
}

//for...in
for(let i in arr){
    console.log(arr[i]);
}
```

